<!DOCTYPE html>
<html lang="en">
<head>
          <title>checkroth-site - Property Testing: Why You Should Generate Test Data</title>
        <meta charset="utf-8" />




    <meta name="tags" content="testing" />
    <meta name="tags" content="property testing" />
    <meta name="tags" content="python" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">checkroth-site <strong>My Notes & Blog</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/blog_index.html">Blog</a></li>
            <li><a href="/archives.html">Archives</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/">About Me</a></li>
            <li><a href="/category/blog.html">blog</a></li>
            <li class="active"><a href="/category/software-blog.html">software blog</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/property-testing.html" rel="bookmark"
         title="Permalink to Property Testing: Why You Should Generate Test Data">Property Testing: Why You Should Generate Test Data</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2017-08-31T00:00:00+09:00">
      August 31, 2017
    </time>
    <address class="vcard author">
      By           <a class="url fn" href="/author/charles-heckroth.html">Charles Heckroth</a>
    </address>
    <div class="category">
        Category: <a href="/category/software-blog.html">software blog</a>
    </div>
    <div class="tags">
        Tags:
            <a href="/tag/testing.html">testing</a>
            <a href="/tag/property-testing.html">property testing</a>
            <a href="/tag/python.html">python</a>
    </div>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>This post is cross-posted to <a href="https://dev.to/checkroth/property-testing-why-you-should-generate-test-data">dev.to</a></p>
<p>I drank the functional programming cool-aid at my first <em>real</em> job. While I do not currently professionally develop with functional programming, I still apply what functional concepts I can -- property testing is a big one.</p>
<p>I'm going to cover three main points:
- What's so special about property testing?
- How can I avoid over-complicating my tests when I can't predetermine expected results?
- When <em>shouldn't</em> I use property testing? </p>
<h1>What's so special about property testing?</h1>
<p>Of all the tools available in a functional library, Haskell's <em>quickcheck</em> is the one I see most re-purposed in other non-functional languages.</p>
<p>At first glance, property testing looks like a fancy way of saying "generating test data", and in a sense, it is. So why is it "property" testing?</p>
<p>When you test a function with predetermined parameters, what you're really testing is that the function works for those inputs. You could add a <em>lot</em> of test parameters, enough to cover an "acceptable" range, but that's a lot of unnecessary work and nobody is likely to actually do it (though I have seen it).</p>
<p>When you <em>property</em> test, you don't care what the input is - you're not testing that the function returns some value when given some input. You're testing that the function, when given an argument that fits its requirements (lets say an "int"), will do <em>something</em> and return the appropriate response to whatever input it was given.</p>
<p>Let's look at a very simple example, an adder:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span>
</pre></div>


<p>Simple, it takes two <code>int</code>s and returns the sum. That's the property - this function "returns the sum of two ints".</p>
<p>Let's look at a pretty standard test:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tests</span><span class="p">:</span>
  <span class="nd">@pytest.mark.parametrize</span><span class="p">(</span><span class="s2">&quot;input1,input2,expect&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
  <span class="k">def</span> <span class="nf">test_adder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">expect</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>This test passes: <code>2 passed in 0.02 seconds</code>. We would expect it to - the sum of 1 and 1 is 2, the sum of 2 and 2 is 4. But that's <em>not what this is testing</em>.</p>
<p>Let's add some more "adders":</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">adder2</span><span class="p">(</span><span class="n">i1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i2</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">4</span>

<span class="k">def</span> <span class="nf">adder3</span><span class="p">(</span><span class="n">i1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i2</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">i1</span><span class="o">*</span><span class="mi">2</span>
</pre></div>


<p>And let's run the same test on those:</p>
<div class="highlight"><pre><span></span>  <span class="nd">@pytest.mark.parametrize</span><span class="p">(</span><span class="s2">&quot;input1,input2,expect&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
  <span class="k">def</span> <span class="nf">test_adder1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">expect</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">adder2</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>

  <span class="nd">@pytest.mark.parametrize</span><span class="p">(</span><span class="s2">&quot;input1,input2,expect&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
  <span class="k">def</span> <span class="nf">test_adder2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">,</span> <span class="n">expect</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">adder3</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>Tests are still passing: <code>6 passed in 0.02 seconds</code>
Our tests aren't testing the <em>property</em> of this function, only some <em>explicit</em> result for some <em>explicit</em> input.</p>
<p>Now lets take a look at <a href="https://pypi.python.org/pypi/pytest-quickcheck">pytest-quickcheck</a>
This library gives us a new way of specifying test arguments: <code>@pytest.mark.randomize</code>. Let's re-write our first test with it.</p>
<div class="highlight"><pre><span></span>    <span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">i1</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_adder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="n">expect</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span>
        <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>Note that I build expect in the test - we can't predetermine the output when we don't know the input.
This test will pass: <code>9 passed in 0.03 seconds</code></p>
<p>Now lets add the rest of the tests:</p>
<div class="highlight"><pre><span></span>    <span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">i1</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_adder2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="n">expect</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span>
        <span class="k">assert</span> <span class="n">adder2</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>

    <span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">i1</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_adder3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="n">expect</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span>
        <span class="k">assert</span> <span class="n">adder3</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>You wouldn't expect these tests to work - adder2 is an if statement and will explode when its first parameter isn't 1 or 2. Adder3 isn't an adder at all - it multiplies.</p>
<div class="highlight"><pre><span></span>E       assert -4819122279534621102 == -6480923863972990104
E        +  where -4819122279534621102 = adder3(-2409561139767310551, -4071362724205679553)

tests2.py:33: AssertionError
</pre></div>


<p>Our test is actually testing that our <code>adder</code> is <em>adding</em>. This might seem like overkill (especially since the test completely re-implements the function), but as you test more complicated functions it begins to make a lot more sense.</p>
<h1>How can I avoid over-complicating my tests when I can't predetermine expected results?</h1>
<p>You might consider the "weakness" of property testing to be the fact that you have to write so much <em>logic</em> in your tests - many people turn their noses at the thought! Why should you have to write logic in your tests, especially as they begin to resemble the thing you're testing in the first place?</p>
<p>First, it's actually <em>okay</em> to re-implement your entire function in your test. Especially in a case like adder. The import part is that your test becomes a static part of your project that will do two things: Prove your function works, and prevent you from breaking the function in the future.</p>
<p>A lot of your tests are going to be for more complicated functions - <code>adder</code> is an oversimplified example. Let's look at a function that uses more complicated structures.
This function will take a collection of dicts containing x and y coordinates, and calculate statistics for the quadrants of a graph based on where the collection's entries lay.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_graph_quadrants</span><span class="p">(</span><span class="n">entries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
    <span class="n">quadrants</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;quad1&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="s1">&#39;quad2&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="s1">&#39;quad3&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="s1">&#39;quad4&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="n">quadrant</span> <span class="o">=</span> <span class="n">calc_quadrant</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;quad{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quadrant</span><span class="p">)</span>
        <span class="n">quadrants</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">quad_stats</span> <span class="ow">in</span> <span class="n">quadrants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">quad_stats</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad_stats</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">total</span>
    <span class="k">return</span> <span class="n">quadrants</span>

<span class="k">def</span> <span class="nf">calc_quadrant</span><span class="p">:</span> 
    <span class="c1"># takes an x and y, returns quadrant of graph coordinates land</span>
    <span class="o">...</span>
</pre></div>


<p>This looks a bit harder to test than <code>adder</code> - we have to build this <code>entries: List[Dict[Any, Any]]</code>, and somehow determine the expect counts and shares per quadrant. We could generate our data like this:</p>
<div class="highlight"><pre><span></span>    <span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">xl</span><span class="o">=</span><span class="n">list_of</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span>
                           <span class="n">yl</span><span class="o">=</span><span class="n">list_of</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">test_calculate_graph_quadrants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xl</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>


<p>But I wouldn't recommend it - this would require a complete re-implementation of the function. I'm not even going to write what the test would look like because its not worth the effort.</p>
<p>The key to writing a <em>clean</em> property test for a complicated function is to <em>reduce</em> unknowns from your generated data as much as you can without reducing the strength of your test.</p>
<div class="highlight"><pre><span></span>    <span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">min_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_num</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_calculate_graph_quadrants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">q3</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">q4</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span><span class="p">,</span> <span class="n">q4</span><span class="p">)</span>
</pre></div>


<p>We're not testing the ability to determine what quadrants the coordinates fall in to - that's a different function. We can assume that it works as intended and write another test for that function later.
So all we <em>really</em> need to make variable is how many entries for each quadrant we want to pass to the function. You could make each a different length, but there is little value in that - we can keep our test simple by passing the same amount of data for each expected quadrant.</p>
<p>Since we know how many entries will fall in to each quadrant, the expected result is actually easy to calculate:</p>
<div class="highlight"><pre><span></span>    <span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">min_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_num</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_calculate_graph_quadrants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">q3</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">q4</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">q3</span><span class="p">,</span> <span class="n">q4</span><span class="p">)</span>
    <span class="c1"># repeat the count for each quadrant, so the total is simple</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">count</span><span class="o">*</span><span class="mi">4</span>
    <span class="c1"># Each quadrant has the same count - the expected share will also be the same.</span>
    <span class="n">expected_share</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">total</span>
    <span class="c1"># we could also do expected_share = .25</span>
    <span class="n">expect</span> <span class="o">=</span> <span class="p">{</span> <span class="n">q</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="s1">&#39;share&#39;</span><span class="p">:</span> <span class="n">expected_share</span><span class="p">}</span>
               <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;quad1&#39;</span><span class="p">,</span> <span class="s1">&#39;quad2&#39;</span><span class="p">,</span> <span class="s1">&#39;quad3&#39;</span><span class="p">,</span> <span class="s1">&#39;quad4&#39;</span><span class="p">]}</span>
    <span class="k">assert</span> <span class="n">calculate_graph_quadrants</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>This test will pass, given that <code>calc_quadrant</code> is accurate. That's not too bad, we don't really have that much logic in the test. By controlling what we do and don't want to be randomized, we can determine what our function is supposed to return fairly easily.</p>
<p><em>Side note:</em> We are all slaves to the limitations of our tools. If we had a library like Scala's <code>scalacheck</code>, we would be able to write a generator for <code>entries</code> that builds the same thing without writing the logic in our tests.</p>
<h1>When <em>Shouldn't</em> I Use Property Testing?</h1>
<p>You should <em>always</em> use property testing. But some libraries aren't cut out for generation on a limited spectrum that you might want. The following could all be done with <code>scalacheck</code>'s custom generators, but with <code>pytest-quickcheck</code> it simply isn't possible.</p>
<p>Let's demonstrate with a test for <code>calc_quadrant</code>. Here's the function:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_quadrant</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
</pre></div>


<p>We could say that this function has four tightly-defined properties, extending from the four logical paths of x and y's sign (+/-). We <em>could</em> randomly generate x and y and build assert like this:</p>
<div class="highlight"><pre><span></span><span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_calc_quadrant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expect</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expect</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expect</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expect</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">calc_quadrant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>Look at that, we've just copied the whole function over to the test. I know I said its okay to essentially re-implement your function in your test, but in this case I don't really want to. We can achieve a worthwhile result using <code>parametrize</code>, giving all permutations of x and y's signage.</p>
<div class="highlight"><pre><span></span><span class="nd">@pytest.mark.parametrize</span><span class="p">(</span><span class="s2">&quot;x,y,expect&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">test_calc_quadrant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">expect</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">calc_quadrant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">expect</span>
</pre></div>


<p>We still want to use property testing here though, to cover that any range of the test's input will produce an output in our finite range (1-4).</p>
<div class="highlight"><pre><span></span><span class="nd">@pytest.mark.randomize</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_calc_quadrant_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">expect_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">calc_quadrant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expect_range</span>
</pre></div>


<p>This way we can prove that the test will only produce an int corresponding to one of four quadrants. Couple this with the manual quadrant test and we have covered enough of the functionality to make most people happy. Obviously <code>calc_quadrant</code> <em>could</em> match specifically for -1 and 1 for our x and y values and otherwise just return <code>1</code>, which would satisfy both tests.</p>
<p>Whether or not to implement the former property test (which re-implements the function) is really up to you. I would personally only do that if this were black box testing and I couldn't just look at the code to know that it isn't just matching specific values. Otherwise I would say that manual testing for quadrants and property testing for the result being within range is "close enough".</p>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>